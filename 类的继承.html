<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>类的继承</title>
</head>
<body>
    <script>
        // 1,原型链继承   将父类的实例作为子类的原型

        // function Animal(name) {
        //     this.name = name || "animal";
        //     this.sleep = function () {
        //         console.log(this.name + "正在睡觉");
        //     }
        // }
        //
        // Animal.prototype.eat = function (food) {
        //     console.log(this.name + "正在吃" + food)
        // };
        //
        // function Cat() {
        //     this.name = "cat";
        // }
        // Cat.prototype = new Animal();
        //
        // var cat = new Cat();
        //
        // console.log(cat);
        // cat.eat("fish");
        // cat.sleep();
        //
        // console.log(cat instanceof Animal);
        // console.log(cat instanceof Cat);


        // 2.构造继承，实际上里利用call来改变Cat中this的指向

        // function Animal(name) {
        //     this.name = name || "animal";
        //     this.sleep = function () {
        //         console.log(this.name + "正在睡觉");
        //     }
        // }
        // Animal.prototype.eat = function (food) {
        //     console.log(this.name + "正在吃" + food);
        // };
        //
        // function Cat() {
        //     this.name = "cat";
        //     Animal.call(this);
        // }
        //
        // var cat = new Cat();
        // console.log(cat);
        // console.log(cat.name);
        // cat.sleep();
        // console.log(cat instanceof Animal);
        // console.log(cat instanceof Cat)

        // 3,实例继承  为父实例添加新特性，作为代码实例返回

        // function Animal(name) {
        //     this.name = name || "animal";
        //     this.sleep = function () {
        //         console.log(this.name + "正在睡觉");
        //     }
        // }
        // Animal.prototype.eat = function (food) {
        //     console.log(this.name + "正在吃" + food);
        // };
        //
        // function Cat(name) {
        //     var instanc = new Animal();
        //     instanc.name = name || "tom";
        //     return instanc;
        // }
        //
        // var cat = new Cat();
        // console.log(cat);
        // console.log(cat.name);
        // cat.sleep();
        // cat.eat("fish");
        // console.log(cat instanceof Animal);
        // console.log(cat instanceof Cat);

        //4,拷贝继承  将父类的属性和方法拷贝一份到子类中

        // function Animal(name) {
        //     this.name = name || "animal";
        //     this.sleep = function () {
        //         console.log(this.name + "正在睡觉");
        //     }
        // }
        // Animal.prototype.eat = function (food) {
        //     console.log(this.name + "正在吃" + food)
        // };
        //
        // function Cat() {
        //     var animal = new Animal();
        //     for (var p in animal) {
        //         Cat.prototype[p] = animal[p];
        //     }
        //     Cat.prototype.name = name || "tom";
        // }
        //
        // cat = new Cat("cat");
        // console.log(cat);
        // console.log(cat.name);
        // cat.sleep();
        // cat.eat("fish");
        // console.log(cat instanceof Animal);
        // console.log(cat instanceof Cat);

        // 5,组合继承   通过调用父类的构造，继承父类的属性，并保留传参的优点
        //             通过将父类实例作为子类的原型，实现父类原型方法的继承

        // function Animal(name) {
        //     this.name = name || "animal";
        //     this.sleep = function () {
        //         console.log(this.name + "正在睡觉");
        //     }
        // }
        // Animal.prototype.eat = function (food) {
        //     console.log(this.name + "正在吃" +food);
        // };
        //
        // function Cat(name) {
        //     Animal.call(this);
        //     this.name = name || "tom";
        // }
        // Cat.prototype = new  Animal();
        // Cat.prototype.constructor = Cat;
        //
        // var cat = new Cat("cat");
        //
        // console.log(cat);
        // console.log(cat.name);
        // cat.sleep();
        // cat.eat("fish");
        // console.log(cat instanceof Animal);
        // console.log(cat instanceof Cat);

        // 6,寄生组合继承
        // function Animal(name) {
        //     this.name = name || "animal";
        //     this.sleep = function () {
        //         console.log(this.name + "正在睡觉")
        //     }
        // }
        // Animal.prototype.eat = function (food) {
        //     console.log(this.name  + "正在吃" + food)
        // };
        //
        // function Cat(name) {
        //     Animal.call(this);
        //     this.name = name || "tom";
        // }
        // (function () {
        //     var Super = function () {};
        //     Super.prototype = Animal.prototype;
        //     Cat.prototype = new Super();
        // })();
        //
        // var cat = new Cat("cat");
        // console.log(cat);
        // console.log(cat.name);
        // cat.sleep();
        // cat.eat("fish");
        // console.log(cat instanceof Animal);
        // console.log(cat instanceof Cat);


        // 7, ES6的extends继承
        // ES6 的继承机制是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this

       class Person {
           constructor(name) {
                this.name = name
           }

           eat () {
               console.log(`${this.name} eat something`)
           }
       }

       class Student extends Person {
           constructor(name, number) {
               super(name)
               this.number = number
           }

           play() {
               console.log(`姓名 ${this.name} 学号 ${this.number}`)
           }
       }

        const xiaoming = new Student("小明", 100);
        console.log(xiaoming.name);
        console.log(xiaoming.number);
        xiaoming.eat();
        xiaoming.play();

    </script>
</body>
</html>